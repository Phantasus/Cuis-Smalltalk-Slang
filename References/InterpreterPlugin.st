'From Squeak5.3 of 3 March 2020 [latest update: #19431] on 23 May 2020 at 6:58:41 pm'!
VMClass subclass: #InterpreterPlugin
	instanceVariableNames: 'interpreterProxy moduleName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'VMMaker-Plugins'!
!InterpreterPlugin commentStamp: 'tpr 5/5/2003 11:43' prior: 0!
This class provides the basic framework for creating VM plugins. Most of the useful methods are on the class side; particularly take note of the messages like #shouldBeTranslated and #requiresPlatformFiles.!


!InterpreterPlugin methodsFor: 'initialize' stamp: 'ikp (auto pragmas 12/08) 8/3/2004 19:18'!
getInterpreter
	"Note: This is coded so that plugins can be run from Squeak."

	<returnTypeC: 'VirtualMachine *'>
	^interpreterProxy! !

!InterpreterPlugin methodsFor: 'initialize' stamp: 'ar (auto pragmas dtl 2010-09-28) 5/13/2000 02:00'!
getModuleName
	"Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important!!"
	<returnTypeC: 'const char*'>
	<export: true>
	^moduleName! !

!InterpreterPlugin methodsFor: 'initialize' stamp: 'ar (auto pragmas 12/08) 4/4/2006 20:53'!
setInterpreter: anInterpreter 
	"Note: This is coded so that is can be run from Squeak."

	| ok |
	<export: true>
	<var: #anInterpreter type: #'struct VirtualMachine*'>
	interpreterProxy := anInterpreter.
	ok := self cCode: 'interpreterProxy->majorVersion() == VM_PROXY_MAJOR'.
	ok == false ifTrue: [^ false].
	ok := self cCode: 'interpreterProxy->minorVersion() >= VM_PROXY_MINOR'.
	^ ok! !


!InterpreterPlugin methodsFor: 'debugging' stamp: 'yo 1/1/2004 11:09'!
halt
	self cCode: '' inSmalltalk: [nil halt].! !

!InterpreterPlugin methodsFor: 'debugging' stamp: 'tpr (auto pragmas dtl 2010-09-28) 12/29/2005 16:34'!
msg: s 
	<var: #s type: 'char *'>
	self cCode: 'fprintf(stderr, "\n%s: %s", moduleName, s)' inSmalltalk: [Transcript cr; show: self class moduleName , ': ' , s; endEntry]! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

InterpreterPlugin class
	instanceVariableNames: ''!

!InterpreterPlugin class methodsFor: 'accessing' stamp: 'tpr 12/17/2003 16:52'!
allCallsOn
	"Answer a SortedCollection of all the methods that refer to me. Most classes simply defer to SystemDictionary>allCallsOn: but some have special requirements - plugins may have a module name that does not match the class name"

	self theNonMetaClass name ~= self moduleName asSymbol
		ifTrue:[^super allCallsOn, (self systemNavigation allCallsOn: self moduleName asSymbol)]
		ifFalse:[^super allCallsOn]! !

!InterpreterPlugin class methodsFor: 'accessing' stamp: 'RMF 3/27/2000 09:39'!
isCPP
	^ false! !

!InterpreterPlugin class methodsFor: 'accessing' stamp: 'bf 10/3/2014 04:20'!
moduleExtension
	Smalltalk at: #JSCodeGenerator ifPresent: [:js | js isActive ifTrue: [^'.js']].
	^ self isCPP ifTrue: ['.cpp'] ifFalse: ['.c']! !

!InterpreterPlugin class methodsFor: 'accessing' stamp: 'bf 10/1/2014 10:02'!
moduleFileName
	"Answer the file name to generate our source code in"

	^ self moduleName, self moduleExtension! !

!InterpreterPlugin class methodsFor: 'accessing' stamp: 'sma 3/3/2000 12:24'!
moduleName
	"Answer the receiver's module name that is used for the plugin's C code."

	^ self name asString! !

!InterpreterPlugin class methodsFor: 'accessing' stamp: 'TPR 5/23/2000 15:33'!
moduleNameAndVersion
	"Answer the receiver's module name and version info that is used for the plugin's C code. The default is to append the code generation date, but any useful text is ok (keep it short)"

	^ self moduleName, Character space asString, Date today asString! !


!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 5/12/2000 00:24'!
baseDirectoryName
	"Return the directory into which plugins should be generated by default."
	^FileDirectory default pathName! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'dtl 8/21/2011 21:10'!
buildCodeGenerator
	"Build a CCodeGenerator for the plugin"
	 | cg |
	cg := self codeGeneratorClass new initialize.
	cg pluginName: self moduleName.
	"Add an extra declaration for module name"
	cg declareModuleName: self moduleNameAndVersion.
	cg declareMethodsStatic: true.
	"Certain plugins expect their methods to be referenced by support code
	even if not so declared. Do not prune methods for those plugins."
	cg permitMethodPruning: (self doNotPruneClasses includes: self moduleName) not.
	^self initializeCodeGenerator: cg.
! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'dtl 8/6/2016 19:13'!
buildCodeGeneratorUpTo: aPluginClass
	"Build a CCodeGenerator for the plugin - Deprecated and here only in case old plugin code tries to use it"
	self deprecated: 'in case old plugin code tries to use it'.
	^self buildCodeGenerator! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 5/12/2000 00:34'!
declareCVarsIn: aCCodeGenerator
	"Note: This method must be implemented by all subclasses to declare variables."

	aCCodeGenerator 
		var: #interpreterProxy 
		type: #'struct VirtualMachine*'.
	self declareHeaderFilesIn: aCCodeGenerator.! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'tpr 5/23/2001 17:14'!
declareHeaderFilesIn: aCCodeGenerator
	self hasHeaderFile ifTrue:[
		aCCodeGenerator addHeaderFile: '"', self moduleName,'.h"'].! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'dtl 8/21/2011 23:00'!
doNotPruneClasses
	"Classes identified by these module names are known to have methods
	that are not exported, but are required by support code. For these classes,
	do not attempt to prune unreference methods in code generation."

	^ { 'RomePlugin' }

! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'tpr 5/23/2001 17:03'!
hasHeaderFile
	"If there is a single intrinsic header file to be associated with the plugin, here is where you want to flag"
	^false! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'dtl 2/23/2014 21:45'!
initializeCodeGenerator: cg
	"Load a code generator with classes in a manner suitable for generating
	code for this class."

	super initializeCodeGenerator: cg.
	VMMaker addMemoryAccessTo: cg.
	^cg
! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'tpr 5/28/2008 19:03'!
isSuitablePluginForPlatform: platName
"Is this plugin one that should be built for platName? We do NOT test for the existence of any external files here"
	"generic answer is true"
	^true! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'tpr 2/27/2004 19:05'!
requiredMethodNames
	"return the list of method names that should be retained for export or other support reasons"
	"just which methods?"
	^#()! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'tpr 7/2/2001 16:33'!
requiresCrossPlatformFiles
	"default is ok for most, any plugin needing cross platform files aside from a normal header must say so. See SoundCodecPlugin for example"
	^self hasHeaderFile! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'tpr 11/21/2000 11:53'!
requiresPlatformFiles
	"default is ok for most, any plugin needing platform specific files must say so"
	^false! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'tpr 5/14/2001 12:05'!
shouldBeTranslated
"is this class intended to be translated as a plugin? Most subclasses should answer true, but some such as:-
	TestInterpreterPlugin
	FlippArrayPlugin2
	InflatePlugin
	should answer false for various reasons."
	^true! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'tpr 9/26/2001 07:27'!
storeString: s onFileNamed: fileName
	"Store the given string in a file of the given name."

	| f |
	f := CrLfFileStream forceNewFileNamed: fileName.
	f nextPutAll: s.
	f close.! !

!InterpreterPlugin class methodsFor: 'translation' stamp: 'bf 10/1/2014 10:03'!
translateInDirectory: directory doInlining: inlineFlag
"This is the default method for writing out sources for a plugin. Several classes need special handling, so look at all implementors of this message"
	| cg fname fstat |
	 fname := self moduleFileName.

	"don't translate if the file is newer than my timeStamp"
	fstat := directory entryAt: fname ifAbsent:[nil].
	fstat ifNotNil:[self timeStamp < fstat modificationTime ifTrue:[^nil]].

	self initialize.
	cg := self buildCodeGenerator.
	cg storeCodeOnFile:  (directory fullNameFor: fname) doInlining: inlineFlag.
	^cg exportedPrimitiveNames asArray! !


!InterpreterPlugin class methodsFor: 'private' stamp: 'tpr 6/9/2003 16:41'!
codeGeneratorClass
	"return the appropriate class of code generator for this kind ofplugin"

	^VMPluginCodeGenerator! !


!InterpreterPlugin class methodsFor: 'instance creation' stamp: 'ar 12/31/2001 01:36'!
doPrimitive: primitiveName 
	| proxy plugin |
	proxy := InterpreterProxy new.
	proxy loadStackFrom: thisContext sender.
	plugin := self simulatorClass new.
	plugin setInterpreter: proxy.
	(plugin respondsTo: #initialiseModule) ifTrue:[plugin initialiseModule].
	plugin perform: primitiveName asSymbol.
	^ proxy stackValue: 0! !


!InterpreterPlugin class methodsFor: 'class initialization' stamp: 'ar 9/16/1998 20:26'!
initialize
	"Nothing to do ..."! !


!InterpreterPlugin class methodsFor: 'simulation' stamp: 'eem 10/1/2010 20:35'!
newFor: anUnsimulatedInterpreterPluginClass
	"Overridden by SmartSyntaxPluginSimulator to wrap a specific plugin class."
	^self new! !

!InterpreterPlugin class methodsFor: 'simulation' stamp: 'ajh 8/21/2002 21:43'!
simulatorClass
	"For running from Smalltalk - answer a class that can be used to simulate the receiver, or nil if you want the primitives in this module to always fail, causing simulation to fall through to the Smalltalk code.  By default every non-TestInterpreterPlugin can simulate itself."

	^ self! !


!InterpreterPlugin class methodsFor: 'compiling' stamp: 'tpr 2/17/2005 13:19'!
noteCompilationOf: aSelector meta: isMeta
	"note the recompiliation by resetting the timeStamp "
	timeStamp := Time totalSeconds.
	^super noteCompilationOf: aSelector meta: isMeta! !


!InterpreterPlugin class methodsFor: 'as yet unclassified' stamp: 'tpr 11/23/2015 16:46'!
pruneUnusedInterpreterPluginMethodsIn: ignored
	"In the Cog VMMaker/InterpreterPlugin this method removes unneeded plugin methods. Here, now, it does nothing"! !


InterpreterPlugin initialize!
